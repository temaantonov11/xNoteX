[[C]]

Массив это структура данных, в которой хранится фиксированное число однотипных элементов. Например, в массиве могут находиться 10 чисел типа `int`.

В памяти массивы всегда занимают непрерывный участок. Это означает, что данные уложены последовательно, элемент за элементом. 
```c
int arr[] = {42, 43, 44};
```
Предположим, массив `arr[]` начинается с адреса 1430 (размер `int` равен 4 байта). Тогда элементы располагаются в памяти вот так:
![[Pasted image 20241228162906.png]]

В массиве размера *n* каждому элементу соответствует порядковый номер от *0* до *n-1*;
Этот номер используется для обращения к элементам массива. 
#### Смещения
Начальный элемент массива расположен со смещением 0 относительно адреса начала массива. Следующий элемент расположен со смещением 4 (это размер одного элемента), затем 8, и так далее. Поэтому и индексы в массиве начинаются с нуля: фактически, элемент с индексом *i* хранится со смещением **(*i* × элемента массива)**

Имя массива можно использовать как адрес первого элемента:
```c
*arr = 999; // эквивалентно arr[0] = 999;
```

#### Определение массива
Можно также определить массив, указав его размер. В зависимости от того, указаны ли иниициализаторы в фигурных скобках, есть варианты: 
```c
// массив не инициализован, значения могут быть мусорными
int arr[5];

// оставшиеся члены инициализированы нулями: {1, 2, 0, 0, 0}
int arr[5] = {1, 2};

// частный случай предыдущего: массив заполнен нулями
int arr[5] = {0};

// все нули, кроме специально обозначенных элементов: {0, 0, 29, 0, 15}
int arr[5] = { [2] = 29, [4] = 15};

```

#### Указатели и массивы
С помощью указателей и арифметики можно обращаться к разным частям массивов. Для примера возьмем указатель `p` типа `int*`. Мы можем прибавить к нему любое целое число `n`, при этом язык позаботиться о том, чтобы фактическое значение указателя изменилось на `n × sizeof(int)`. 
```c
int* p = 10;
p = p + 3; // 10 + 3*sizeof(int) = 22
p = p - 2; // 22 - 2*sizeof(int) = 14
```
Результат сложения с числом является корректным указателем, пока мы не выходим за пределы массива справа или слева. 

Теперь создадим 2 указателя одного типа `p` и `q` где-то в середине массива:
```c
int arr[100];
int* p = array + 40; // адрес 40-ого элемента массива
int* q = &array[60]; // адрес 60-ого элемента массива (альтернативная форма)
```
С двумя указателями мы можем делать следующие операции:
```c
if (p <= q) { // проверить, что указатель q указывает на правый элемент
	int s = q - p; // посчитать кол-во элементов между p и q
	printf("%d\n", s);
}
```

Невозможно сложить два указателя, переменожить и поделить их; унарный минус тоже не имеет смысла. 

Видим, что массивы и указатели очень похожи. Для любого указателя или массива `p`: 
- `p[i]` означает то же самое, что `*(p +i)`
- `&p[i]` означает тоже самое что `p + i`

#### Передача массивов в функции
Традиционно есть два способа передачи массивов в функции:
1. Передать указатель на первый элемент и размер массива
```c
void print_int(int arg) {
	printf("%d ", arg);
}

// array - указатель на первый элемент, size - размер массива

void print_array(int* array, int size) {
	for (int i = 0; i < size; ++i) {
		print_int(array[i]);
	}
}
```

![[Pasted image 20241228170246.png]]

2. Передать указатель на начало массива и на элемент **сразу после последнего**.
В этом случае можно пройтись по массиву увеличивая указатель так, что он сначала указывает на первый элемент, затем на второй, и так далее. Когда мы дошли до указателя **за последним элементом**, можно остановиться. 
Передача указателя на элемент, который идет сразу после последнего позволяет передать массивы нулевой длины: для них указатель на начало массива будет равен указателю на элемент "сразу за последним". 
```c
void print_array(int* array, int* limit) {
	for (int* current = array; current < limit; ++current) {
		print_int(*current);
	}
}
```

![[Pasted image 20241228171039.png]]

