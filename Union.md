[[C]]

**Union** - позволяют определить свой тип данных и хранят набор элементов, но в отличие от структуры *все элементы объединения имеют нулевое смещение*. А это значит, что разные элементы занимают в памяти один и тот же участок, то есть они накладываются друг на друга.
## Синтаксис

```C
union имя_объединения {
	тип элемента1;
	тип элемента2;
	..............
	тип элементаN;
};
```
## Пример

```C
union ascii {
	int digit;
	char letter;	
};
```

Объединение `ascii` хранит в одном и том же участке памяти объект `int` (числовой код символа) и объект `char` (сам символ). Конкретный размер выделенной памяти будет зависеть от системы и реализации, но в общем случае это будет выглядить примерно так:

![[Pasted image 20250212183431.png | 350]]

В этом случае union `ascii` на большинстве платформ будет занимать *4 байта*. Длина элементов, как здесь, может быть разной, и в этом случае размер объединения вычисляется **по наибольшему элементу**.

## Coding example

```C

#include <stdio.h>
#include <inttypes.h>

union qword {
    int64_t integer[2];
    int32_t parts[2];
};

int main() {
    union qword test;
    test.integer[0] = 0xAABBCCDDEEFF1122;
    test.integer[1] = 0xAABBCCDDEEFF1111;
    printf("value of integers: %" PRIx64 ", %" PRIx64 "\n", test.integer[0], test.integer[1]);
    printf("value of parts: %" PRIx32 ", %" PRIx32 "\n", test.parts[0], test.parts[1]);
    printf("Address of integers: %" PRIxPTR ", %" PRIxPTR "\n", (uintptr_t)&(test.integer[0]), (uintptr_t)&(test.integer[1]));
    printf("Address of parts: %" PRIxPTR ", %" PRIxPTR "\n", (uintptr_t)&(test.parts[0]), (uintptr_t)&(test.parts[1]));
    return 0;
}
```

```shell
value of integers: aabbccddeeff1122, aabbccddeeff1111
value of parts: eeff1122, aabbccdd
Address of integers: 7fff15ccc0a0, 7fff15ccc0a8
Address of parts: 7fff15ccc0a0, 7fff15ccc0a4
```

Здесь массив из двух чисел типа `int32_t` накладывается на те же адреса в памяти, что и поле типа `int64_t`.
## Пространства имён

Можно объявить тип-структуру `struct T` и псевдоним для какого-то типа `T`; это не приведет к конфликту

```C
struct T { int64_t value; }
typedef int64_t T;
// конфликта нет
```

**Однако имена структур и объединений находятся в одном пространстве имен**: определив структурный тип `struct T` мы уже *не сможем определить тип-объединение* `union T` (и наоборот).

```C
struct T { int64_t value; }
union T { int64_t value; }
// конфликт со struct T
```
## Комбинирование struct и union

Мы можем определять структуры и объединения как части других структур и объединений.
Это позволяет делать много любопытных вещей. 

Например, в объединении `union pixel` можно обращаться к трём элементам массива `char` по именам или по индексам.

```C
struct pixel_explicit {
	uint8_t a;
	uint8_t b;
	uint8_t c;
}

union pixel {
	struct pixel_explicit named;
	uint8_t at[3];
}

union pixel p;
p.named.b == p.at[1]; // всегда верно
```

Разумеется, этот код будет **работать корректно только в определённых условиях** (например, поля в `pixel_explicit` должны лежать одно за другим без пропусков), поэтому хорошенько подумайте, прежде чем такое писать.
## Применение объединений

Объединения имеют 2 применения:
- Экономия памяти, когда мы переиспользуем одни и те же адреса то для одних данных, то для других.
- Переинтерпретация одних и тех же байтов памяти как данных разных типов.

**Стандарт описывает объединения только с точки зрения экономии памяти**. Иначе говоря, нам гарантируется лишь возможность записать значение в поле объединения и потом прочитать его из того же поля; записи в другие поля объединения сразу же запрещают чтения из первоначального поля. 

В общем случае, после записи в любое поле объединения значения остальных полей становятся неопределенными. Исключение из этого правила это объединение из нескольких структур, в начале которых поля одинаковых типов:

```C
struct sa {
	char x;
	int64_t y;
	char z;
};

struct sb {
	char x;
	int64_t y;
	int64_t notz;
};

union test {
	struct sa as_sa;
	struct sb as_sb;
};

union test test_instance;
test_instance.as_sa.y = 100;

// оба чтения гарантированно приведут к одному результату 
printf("%" PRId64, test_instance.as_sb.y ); 
printf("%" PRId64, test_instance.as_sa.y ) ;
```

*Переинтерпретация данных с помощью объединений  считается завязанной на конкретную архитектуру* и её представления данных, поэтому пользуйтесь ей с осторожностью.