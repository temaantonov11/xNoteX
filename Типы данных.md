## Классификация типов

На деле типов в языке достаточно много. Их можно поделить на следующие категории:
- Встроенные численные типы: `int`, `unsigned int`, `unsigned short int`, `char`, `float`,
- Массивы
- Тип `void`, у которого только одно значение, с которым нельзя ничего сделать
- Указатели (в том числе на функции)
- Структурные типы - "пачки" из фиксированного количества элементов разных типов. В математике их называют кортеж.
- Объединения - тип данных, для которых указываются несколько других типов, и данные типа объединения могут быть одним из них
- Перечисления - тип, для которого описывается фиксированное количество целочисленных значений, а данные принимают одно из этих значений.
- Типы функций
- Псевдонимы других типов
- Типы, образованные от других типо с помощью модификаторов `const`, `restrict`, `volatile`

## Численные типы

Целые числа это центральный тип для языка С. Они бывают разного размера, со знаком (могут быть отрицательными) и без знака (только ноль и положительные). 

### Тип `char`

- Может быть знаковым (`signed char`) или беззнаковым (`unsigned char`). Стандарт языка не описывает, что будет, если написать просто `char`, для большинства компиляторов `char` это синоним `signed char`. 
- Размер всегда равен **1 байту**.
- Хотя имя этого типа отсылает нас к слову 'character' (символ), нужно думать о нем как о числе размером 1 байт.
- Литерал `'x'` соответствует ASCII-коду символа "x". Его тип - `int`, не `char`, но стандарт гарантирует, что он уместится в `char`. 
### Тип `int`

- Может быть знаковым и беззнаковым (по умолчанию знаковый).
- Можно просто писать `signed`, `unsigned`. Например:
```c
signed i = -10;
unsigned j = 100;
```
- Может быть помечен `short` (**2 байта**), `long` (4 байта на 32-битных архитектурах, 8 байта на AMD64)
- Большинство компиляторов поддерживают `long long`, стандарт описывает `long long` начиная с С99.
- В зависимости от архитектуры, размер `int` меняется. Изначально задумывалось, чтобы размер `int` соответствовал разрядности архитектуры. Около 30 лет доминирующими были 16-разрядные архитектуры, затем 32-разрядные архитектуры, относительно недавно мы перешли на 64-разрядные. В 32-разрядную эпоху нерадивые программисты написали множество программ из расчет на то, что `int` имеет размер 4 байта и всегда будет таким (хотя если бы они знали историю или знали стандарт, они бы так не стали делать). Программы просто переставали работать, если поменять размер `int` на 8 байт, поэтому чтобы не переписывать огромное количесство приложений размер `int` по прежнему **4 байта**.
- *Важно:* все численные литерали имеют по-умолчанию формат `int`. С помощью суффиксов можно это изменить:
```
42 // int
42L // long int
33UL // unsigned long int
```

### Тип `long`
- На 64-разрядных архитектурах тип `long` как правило занимает столько же места, сколько и `int`; на Windows, правда, 4 байта.

### Тип `long long`
- Размер **8 байт**.

### Типы с плавающей точкой

Также есть типы `float` (число с плавающей точкой размером **4 байт**) и `double` (число с плавающей точкой размером **8 байт**). Литералы с суффиксом `f` считаются числами типа `float`, наример `1.0f`; без него - типа `double`, например `3.1415`

## Платформонезависимые целочисленные типы
В стандарте С99 появились платформонезависимые типы даннах. Они определены в заголовочном файле `stdint.h` и выглядят единообразно:

**Знаковые типы:**
- `int8_t`
- `int16_t`
- `int32_t`
- `int64_t`
**Беззнаковые типы:
- `uint8_t`
- `uint16_t`
- `uint32_t`
- `uint64_t`

В этих типах явно указан их размер и знаковость, что снимает все неоднозначности.

## Конкатенация строковых литералов

Написав два строковых литерала подряд через пробел мы на самом деле их сольём в один, вот так:
```cpp
"hello" "world" // то же самое, что и
"helloworld"
```
Благодаря этому мы можем вставлять в одни строки другие, которые являются частью макроопределения:
```cpp
#define WORLD "world"
"hello, " WORLD "!" // то же самое, что
"hello, world!"
```

## Ввод и вывод с платформонезависимыми типами
Теперь мы можем осознанно использовать полезный механизм, предоставленный заголовочным файлом `inttypes.h`, чтобы использовать новые целочисленные типы в `printf` и `scanf`. Для каждого такого типа нужен собственный спецификатор вывода и ввода. Так же как и с новыми типами нам не потребуется запоминать кучу спецификаторов, но лишь схему формирования макроопределений, которые им соответствуют:
- `PRI` или `SCN` (вывод и ввод)
- Формат: `x` (16-ричный), `u` (беззнаковый), `i` или `d` (знаковый)
- Размер в битах или `PTR` для указателей

```cpp
void f() {
	int64_t i64 = -10;
	uint64_t u64 = 100;
	printf("Signed 64-bit integer: %" PRId64 "\n", i64);
	printf("Unsigned 64-bit integer: %" PRIu64 "\n", u64);
	printf("Pointer, hexadecimal %" PRIxPTR "\n", &i64);
}

int16_t read_int16() {
	int16_t x = 0;
	scanf("%" SCNd16, &x);
	return x;
}
```


> [!NOTE] Важно
> Символы процентов перед спецификаторами нужно указывать явно.

Файл `stdint.h` включается в файл `inttypes.h`, поэтому его содержимое доступно в этом примере.

**Также есть другие типы:** 
- `int_least8_t`
- `uint_fast32_t`
- `intptr_t`
- `intmax_t`

> [!NOTE] ISO
> Документация по этим типам в разделе **7.20** стандарта С

## Псевдонимы для типов
Можно определить для типа произвольное количество псевдонимов с помощью ключевого слова `typedef`. Например, определим псевдоним для чисел `int` подназванием `i32`:
```
typedef int i32;
```

Так реализованы и платформонезависимые типы: разные компиляторы под разные платформы определяют псевдоним `int32_t` для разных типов: где-то это просто `int`, где-то `long int` и т.п

>[!NOTE] Важно
>**Никогда** не снабжайте свои типы суффиксов `_t`, например, `myint_t`. 

## Булевый тип
Раньше в С не было булевого типа, он появился только в стандарте С99.
Программистам при этом всегда не хватало булевого типа. Хотя и предполагалось, что можно использовать вместо него `int`, но это вносило путаницу: например, все функции, которые возвращали `int` делились на 2 категории:
- одни по смыслу возвращают число
- другие по смыслу проверяют условие и возращают "да" или "нет"
Поэтому каждый программист определял свою вариацию этого типа, обычно как псевдоним для `int` под названием `bool`.
В стандарте C99 этот тип  появился, но чтобы не сломать совместимость с большим количеством уже использующих "самодельный" тип `bool`, "официальный" булевый тип в C99 называется `_Bool`. Так избегается конфликт имён. Поэтому в программе, где тип `bool` уже определён самим программистом, можно в дальнейшем использовать `_Bool` в процессе миграции на новый тип.

Если же программист сам не определил тип `bool`, то можно подключить стандартный заголовок `stdbool.h`  и использовать имя `bool`. По возможности нужно делать именно так.

```cpp
#include <stdbool.h>

bool divisible( uint64_t a, uint64_t b ) {
   return a % b == 0; 
}
```

Скорее всего, через несколько итераций стандарта ключевое слово `_Bool` будет объявлено устаревшим, а в дальнейшем его и вовсе удалят; все будут пользоваться `bool`.

## Тип `size_t`

Данные типа `size_t` хранят длину чего-то в байтах: размер массива, одного числа, составного типа данных...или количество, которые варажается натуральным числом. Стандарт гарантирует, что `size_t` достаточно большой, чтобы вместить любую длину массива.
А вот в `int`, например, *длина многих массивов не умещается*. Числом типа `int` размером 4 байта можно описать длину массива не более 2ГБ
(не 4, как `unsigned int`, потому что это знаковое число!). Размер практически любого фильма больше 2ГБ. Напротив, `size_t` на распространненых платформах это беззнаковое восьмибайтовое число, чего достаточно, чтобы записывтаь точную длину файла размером порядка 18 миллиардов ГБ.
**Поэтому нельзя использовать `int` как индекс в массиве или как размер массива.**
Весь язык поощряет использование `size_t` для количества элементов или размера области памяти. Оператор `sizeof` тоже возвращает число типа `size_t`, а не `int`; стандартные библиотечные функции используют `size_t`, например:
- `strlen` считает длину строки
```c
size_t strlen(char* s);
```
- `strncpy` копирует строку в буфер, при этом он допольнительно принимает ограничение по размеру, чтобы не записать в буфер слишком много байт
```c
char* strncpy(char* destination, char* source, size_t num);
```

А если массив маленький, и его размер точно уместиться в `int`? Даже в этом случае есть проблемы:
```c
char* hello = "Hello, world!";
size_t sz = strlen(hello);

// проблема тут
for (int i = 0; i < sz; ++i) {
	...
}
```
На каждой итерации происходит сравнение `i` и `sz`. Но эти числа имеют разный формат (4 байта, знаковое и 8 байт, беззнаковое). Для их сравнения на уровне машинных инструкций придётся добавить дополнительные команды по конвертации их в единый формат, что плохо для производительности.
Кроме того, если нужна производительность, то важно использовать беззнаковые числа для индексов в битовых массивах. В таком случае, чтобы получить доступ к биту по номеру *n* нужно сначала найти в массиве байт под номером *n/8*, а затем найти в нём бит под номером *n%8*. Деление на 8 оптимизируется в побитовые сдвиги вправо, но только для беззнаковых чисел! Сдвиги при этом намного быстрее деления.

>[!info] Спецификтор ввода/вывода для `size_t`
>`%zu`


## Тип `ptrdiff_t`

Функции, использующие работу с массивом, используют один из двух подходов:
- принимают адрес начала массива и адрес сразу после последнего элемента
- принимают адрес начала массива и его размер (размер должен иметь тип `size_t`)
Как правило, используют второй способ, потому что у работы с массивом как с парой указателей неудобно.
Когда мы вычитаем 2 указателя, тип результата - знаковое число `ptrdiff_t`. Его значение, конечно, определено только тогда, когда указатели ссылаются внутрь одного массива. Кроме того, нужно учитывать, что *не любая разность указателей в него вмещается*. 


## Приведение типов (Type Casting)

Возьмем функцию, принимающую `int64_t`:
```c
int64_t square( int64_t x) {
	return x*x;
}
```
Мы можем вызвать ее с аргументом типа `int8_t`:
```c
int8_t a = 42;
printf("%" PRId64, square(a));
```

Интуитивно такая операция имеет смысл, ведь маленькое число надо всего лишь "расширить" до большого. Однако с точки зрения компилятора мы использовали выражение типа `int8_t` вместо выражения типа `int64_t`; для произвольных двух типов так делать нельзя. Например, компилятор откажется принимать число вместо строки (`*char`)
Для некоторых пар типов, однако, мы делаем исключение - в таком случае мы говорим, что в коде происходит *неявное преобразование типов* (**implicit conversion**) в том месте, где мы используем "неподходящий тип".
В общем случае можно сказать, что неявное преобразование из типа А в тип В - это некоторая функция; компилятор замечает "ошибки" типизации в выражениях, где вместо выражения типа В стоит выражение типа А, и исправляет их, вставляя вызов этой функции.
Вот еще один пример: арифметика с дробными и целами числами.
```c
float f = 1.0f + 3;
```
Целые и действительные числа представляются в компьютере совсем по-разному и складывать эти числа в разных форматах просто так нельзя. Сначала их нужно привести к единому формату, а затем производить сложение. Поэтому код на самом деле выглядит для компилятора так:
```c
float f = 1.0f + int_to_float(3);
```
У компилятора заготовлена функция, которую мы здесь назвали `int_to_float`; прежде, чем производить сложение чисел, программа выполнит код конвертации и будет использовать не целое число 3, а число с плавающей точкой `3.0f`.

Также мы можем взять одно выражение и явно сконвертировать к другому типу, если такая конверсия имеет смысл (нет смысла, например, конвертировать число в функцию). Для этого мы пишем новый тип в скобках перед выражением (а само выражение тоже ставим в скобки)
```c
float f = 10.3f;

// число округляется к нулю, просто отбрасываем дробную часть
int64_t i = (int64_t)(f + 4.9f);

// для простых выражений можно опустить скобки
int64_t i = (int64_t)f;
```

Это *явное приведение типов*: мы явно указываем, какое выражение и в какой тип хотим конвертировать. Разумеется, если мы конвертируем данные из какой-то переменной в другой тип, тип самой переменной при этом не меняется, и значение тоже.
**Неявное преобразование**: если определить для типа псевдоним с помощью `typedef`, между типом и псевдонимом появляется неявное преобразование в две стороны.

## Нестрогая типизация
Говорят, что в языке С *нестрогая типизация*. Это означает, что существует достаточно много неявных преобразований типов.
Напротив, если бы количество всего неявного было сведено к минимуму, то мы бы говорили о *строгой типизации*.

## Integer promotion и неявные преобразования чисел

Первые неявные преобразования, которые будут рассмотрены, происходят между числами разного формата. Когда вместо числа типа `А` мы используем число типа `В`, компилятор будет действовать по следующему алгоритму:
1. Если `В` меньшей разрядности, чем `int`, то конвертируем `B -> int` (это называется **integer promotion**). Если `B` знаковый, то мы преобразуем `B -> signed int`, а если беззнаковый, то `B -> unsigned int`.
2. Если полученный тип отличается от `A`, то мы двигаемся дальше по лестнице типов вверх до типа `A`.
```
int -> unsigned int ->
long -> unsigned long ->
long long -> unsigned long long ->
float -> double ->
long double
```
Первый пункт в конверсии очень важен, так как переполнения в меньших типах случаются иначе, нежели в `int`.

Для примера, допустим, что `sizeof(int) == 4`. Возьмем два числа типа `unsigned char` и сложим их так, чтобы результат не поместился в диапазон [0; 255] :
```c
unsigned char x = 150;
unsigned char y = 150;
unsigned char s = x + y; /* = 44*/
```
Значение ожидаемо, усечётся до 44, т.к 300 % 256 = 44

На самом деле, контринтуитивно, в этом коде происходит следующее: операнды конвертируются в тип `unsigned int`, складываются, а затем результат усекается, чтобы вместиться в `unsigned char`.
```c
unsigned char s = (unsigned char)( (unsigned int)x + (unsigned int)y ); 
```
На уровне машинных инструкций такая логика мотивирована тем, что `int` это "родной" для машины формат данных, и чтобы производить арифметику с данными меньших форматов она всё равно приведет их к удобному для себя формату `int`.

Однако по этому же принципу если поместить результат в `unsigned int`, то его значение не будет усекаться:
```c
unsigned int s = x + y; /* = 300 */

// на самом деле это означает
unsigned int s = (unsigned char)x + (unsigned char)y;
```

С другой стороны, начиная с типа `int`, всё происходит проще и логичнее:
```c
/* предполагаем sizeof(int) == 4 */
unsigned int x = 3000000000;
unsigned int y = x;

/* x + y не умещается в unsigned int */
/* r_int = 1705032704 == 6000000000 % (2^32) */
unsigned int r_int = x + y;

/* хотя результат мы кладём в long от переполнения это не спасает */
unsigned long r_long = x + y; // то же самое: 1705032704

/* а так работает */
unsigned long r_long = (unsigned long)x + (unsigned long)y;
```

**Всегда лучше писать не кратко, но понятно и однозначно:**
```c
long x = (long)a + (long)b + (long)c;
```

## Типы указателей и `void*`

Мы знаем, что из любого типа `T` можно образовать тип-указатель `T*`. В данных типа `T*` хранятся адреса данных типа `T`.
Существует специальный тип `void*`, "указатель на что угодно". В переменную типа `void*` можно записать любой указатель. 

>[!tip] Неявное приведение
>Любой указатель можно неявно привести к типу `void*`, т.е использовать как значение переменной или аргумента типа `void*` без явной конверсии.

Все указатели имеют одинаковый размер в рамках одной архитектуры, в случае вашего компьютера это, скорее всего 8 байт.

В общем случае указатели *не обязательно являются числами*. Например, еще 30 лет назад мы пользовались другими ПК, на которых указатели могли иметь форму из пары чисел: базового адреса и смещения относительно него. Однако стандарт требует наличия алгоритма перевода между числами и указателями в две стороны, что позволяет, например, печатать указатели с помощью `printf`:
```c
// по стандарту перед печатью надо приводить указатель явно к типу void*
char x;
char* i = &x;
printf("%p", (void*)&i);
```

Указатель типа `void*` нельзя разадресовать, т.е обратиться по нему. Мы не знаем, на данные какого типа он указывает, поэтому и тип выражения `*p` неясен. Необходимо сначала сконвертировать его в другой тип указателя, а потом обратиться по нему:
```c
int64_t x = 0;
void* p = &x;

// ошибка:
int64_t y = *p;
// правильно:
int64_t y = *((int64_t*)p);
```

Разрешается явно преобразовать тип указателя к другому типу указателя.
## Массивы

Нам часто требуются контейнеры - структуры данных, в которые можно складывать данные одного типа, а затем доставать их оттуда поодиночке или пачками. Массив это один из таких контейнеров, обладающий следующими свойствами:
- Сложно добавлять элементы
- Сложно удалять элементы
- Легко обращаться к элементу по его индексу
- Легко считать количество элементов
- Легко последовательно перечислять элементы

Каждый контейнер делает одни операции легкими и удобными, но другими - сложными и громоздкими. Не бывает идеального контейнера, где все операции максимально быстры и удобны. Мы выбираем контейнер по ситуации, в зависимости от того, какие операции чаще используем. 

На уровне встроенных конструкций язык С поддерживает только один контейнер - массивы. Массивом в С может считать вообще любой набор данных одного типа, которые последовательно лежат в памяти. Типы массивов не совпадают с указателями, но:

>[!tip] Неявное преобразование
>Тип-массив неявно преобразуется в указатель

### Массивы как аргументы функций
Рассмотрим такой пример:
```c
bool starts_with_0(int64_t array[], size_t sz) {
	if (sz == 0) return false;
	return array[0] == 0;
}
```

Нужно обратить внимание на то, что функция принимает массив. Значит ли это, что массив в функцию копируется целиком?
На самом деле, *не передается*. Мы можем переписать функцию эквивалетно так, заменив массив на указатель:
```c
bool starts_with_0(int64_t* array, size_t sz) {
	if (sz == 0) return false;
	return array[0] == 0;
} 
```

Типы-массив в аргументах функции - особый случай, и компилятор автоматически переводит их в типы-указатели.
При передаче массивов через аргументы функций можно указать в квадратных скобках размерность массива, но **она ничего не означает - это комментарий**
```c
// добавив 42 мы не изменим ничего
bool starts_with_0(int64_t array[42], size_t sz) {
	if (sz == 0) return false;
	return array[0] == 0;
}
```

Начиная с версии С99 есть специальный синтаксис чтобы сформулировать ограничение "на вход подается массив, в котором как минимум N элементов". Это может помочь компилятору лучше оптимизировать код. Но оно тоже не проверяется.
```c
// в этом массиве как минимум один элемент
bool starts_with_0(int64_t array[static 1], size_t sz) {
	return array[0] == 0;
}
```

## Константные типы
Для кажого типа `T` мы можем образовать от него неизменяемый тип `const T` (или `T const`, что эквивалентно). Переменные таких типов нельзя изменять напрямую, т.е каким значением мы их инициализировали, такими они и останутся.

```c
int a;
a = 42; // ok

const int a; // compilation error

const int a = 42; // ok
a = 99; // compilation error, нельзя изменять константы
int const a = 42; // ok
const int b = 99; // ok, const int == int const
```

Интересно заметить, что в случае с указателями `const` может относиться или к тому, что указывает (указатель) или к тому, на что указывает:
- `int const* x` значит "изменяемый указатель на неизменняемый `int` ". Нельзя после этого написать `*x = 10;`, но изменять сам `x` можно. То же самое: `const int x`
- `int* const x = &y` значит "неизменяемый указатель на изменяемый `int`". Можно менять значение по указателю, но перенаправлять указатель на другую ячейку памяти - нет.
- `int const* const x = &y` значит неизменяемый указатель на неизменяемые данные; is "an immutable".

>[!info] Правило
>`const` слева от звёздочки защищает то, на что мы указываем; справа - сам указатель.

Тип `void const*` тоже существует

### Как пользоваться неизменяемыми типами

Если вы хотите сделать что-то неизменяемым, это должно быть осознанное решение, а не опция по умолчанию.
#### Параметры функций
Возьмём функцию, которая считает количество положительных чисел в массиве.

```c
size_t count_pos(int64_t* array, size_t sz) {
	size_t count = 0;
	for (size_t i = 0; i < sz; ++i) {
		if (array[i] > 0) {
			count++;
		}
	}
	return count;
}
```

Очевидно, что массив `array` эта функция менять не должна, а если мы случайно это сделаем, это точно ошибка. Поэтому лучше защитить массив от изменения: 

```c
size_t count_pos(const int64_t* array, size_t sz) {
	size_t count = 0;
	for (size_t i = 0; i < sz; ++i) {
		if (array[i] > 0) {
			count++;
		}
	}
	return count;
}
```

Если представить, что я другой программист и смотрю на сигнатуру этой функции:
```c
size_t count_pos(int64_t* array, size_t sz);
size_t count_pos(const int64_t* array, size_t sz);
```
По второму варианта сразу становится понятно, что массив изменяться не будет. Это очень полезная информация.

#### Константы

Традиционно в С глобальные константы определялись с помощью макропроцессора:
```c
#define CONST_NAME 42
```

Во многих случаях лучше определять константы как глобальные неизменяемые переменные; например, потому что они типизированы, а литералы - нет. В некоторых ситуациях это не сработает - например, для размеров массивов.

>[!tip] Неявное приведение
>Любой указатель `T*` неявно приводиться к типу `T const*`; наоборот нельзя, иначе мы нарушим обещание не менять неизменяемые данные.

#### Итог
Я должен выработать привычку делать неизменяемым всё, что только возможно:
- Локальные переменные с промежуточными значениями, которые я создаю для удобства.
- Параметры функций, которые являются указателями
- Глобальные переменные можно использовать только неизменяемые, за редкими исключениями (в контексте многопоточности).
