## Адреса

Память - таблица, в которой каждая ячейка хранит в себе 1 байт данных. Один байт - это 8-битовое число, с помощью восьми битов можно закодировать числа от 0 до 255 включительно. Ячейки памяти пронумерованы так, что каждому байту соответствует его номер, начиная с нуля:

| Номер ячейки              | Содержимое ячейки |
| ------------------------- | ----------------- |
| 0                         | число от 0 до 255 |
| 1                         | число от 0 до 255 |
| 2                         | число от 0 до 255 |
| ...                       | ...               |
| максимальный номер ячейки | число от 0 до 255 |
==Номера ячеек называются адресами памяти.==

## Многобайтовые данные

Большинство данных, с которыми работает компьютер, занимают больше одного байта. Например, числа int занимают 4 последовательно идущих байта, что позволяет им принимать не одно из 256 различных значений, а на 4 порядке больше. 
В памяти переменная типа int будет занимать четыре последовательно идущих ячейки; адресом многобайтового числа будет адрес первой из этих ячеек. 

Для примера, пусть `int x` оказалось в памяти по адресу 8, тогда память будет выглядить так:

| Номер ячейки              | Содержимое ячейки |
| ------------------------- | ----------------- |
| 0                         | число от 0 до 255 |
| 1                         | число от 0 до 255 |
| 2                         | число от 0 до 255 |
| ...                       | ...               |
| 8                         | 1-ый байт x       |
| 9                         | 2-ой байт x       |
| 10                        | 3-ий байт x       |
| 11                        | 4-ый байт x       |
| 12                        | число от 0 до 255 |
| ...                       | ...               |
| ...                       | ...               |
| максимальный номер ячейки | число от 0 до 255 |
## Указатели

Адреса - тоже числа, поэтому с ними можно делать почти всё то же самое, например, создавать переменные, которые хранят адреса, прибавлять к адресам числа. Будут и различия, поэтому для указателей будут использоваться специальные типы. Если у переменной тип `int`, то у переменной, хранящей ее адрес будет тип `*int`. 

```
int x = 10; // переменная int
int* px = &x; // переменная типа *int
// с помощью оператора & мы берем адрес переменной x
```

Можно добавлять сколько угодно уровней косвенности (`int**` это указатель на `int*`)

![[Pasted image 20241228015631.png]]

## Гуляем по памяти

Имея адрес мы можем пройти (dereference, разыменование) по этому адресу с помощью оператора `*`. Это значит, что вместо адреса данных мы будем оперировать с самими данными. 
```c
int x = 10;
int* px = &x;

*px = 42;

```

![[Pasted image 20241228023807.png]]

==в 64-битной системе все указатели занимают 8 байт==

## Неинициализированные указатели

Ячейки памяти всегда хранят какие-то значения, поэтому если создать переменную-указатель и ничего в неё не записать, она всё равно будет равняться какому-то числу (адреса) - мусору.
```c
void somefunction() {
	int bad_ptr; // равен какому-то мусорному значению
}
```
При этом неизвестно, указывает ли такой произвольный адрес вроде 10231234 хоть на какие-то определённые данные, или это "мусорное" значение.

Чтобы отличать некорректные указатели мы используем специальное значение неинициализированного указателя `NULL`
```c
int* px = NULL; // мы точно знаем, что этот указатель никуда не ведет
int* px = 0; // альтернативная форма записи

if (px != NULL){ // проверка на корректность указателя
	... 
}
```

На всех архитектурах будет работать код:
```c
int* px = ...;

// эквивалентные способы проверить, что указатель инициализирован
if (px)
if (px != NULL)
if (px != 0)

// эквивалентные способы проверить, что указатель НЕ инициализирован
if (!px)
if (px == NULL)
if (px == 0)

```

## Оператор sizeof


Чтобы узнать, какой размер занимает тот или иной тип или данные используется оператор `sizeof`. Синтаксически он выглядит как вызов функции, но на самом деле никакой код не выполняет. Вместо выражения `sizeof(<expr of type>)` компилятор подставляет число. 
Скажем, `sizeof(char)` будет заменен на 1 еще до выполнения программы. Также `sizeof` можно применять к любым выражениям; эти выражения не будут выполняться, компилятор просто выведет тип выражения и подставит его размер.
```c
char print() {
	printf("hello");
	return 0;
}

...
int x = sizeof(print()); // x = 1, нет вывода на экран
```

## Указатель на указатель
```c
int x = 10;
int* px = &x;
int** ppx = &px;
```
Допустим, что `x` находится по адресу 1016, `p` по адресу 2056, `pp` по адресу 8000. Можно изобразить это следующим образом:
![[Pasted image 20241229152800.png]]

#### Применение указателя на указатель
```c
#include <stdio.h>

  

int array_min(int* array, int* limit, int** min) {
	if (array >= limit) {
		return 0;
	}
	*min = array;
	for (int* current = array; current < limit; ++current) {
		if (*current < **min) {
		*min = current;
		}
	}
	return 1;
}

  

int main() {

	int array[4] = {1, 23, 404, -8};
	int size = 4;
	int* min = NULL;
	if (array_min(array, array + size, &min)) {
		printf("Min = %d\n", *min);
	} else {
		printf("Array is empty\n");
	}
}
```

### Указатели на локальные переменные
Удобно передавать локальные переменные функции в другие функции по указателям:
```c
void g(int* a) {
	*a = 42;
}

void f() {
	int x = 0;

	g (&x);
}
```
Это работает потому что время жизни локальных переменных `f` больше, чем переменных из любой другой функции, которую `f` вызывает. То есть функции отработают и вернутся в `f`, а затем уже произойдет возврат из `f`. 

> [!NOTE]
> > **Правило:** можно передавать локальные переменные функции `f` по указателям в те функции, которые `f` вызывает, но не "вверх" в функции, вызывающие `f`.
> 

Но нельзя возвращать из функции указатель на её локальную переменную: 
```c
int* g() {
	int a = 42;
	return &a;
}

void f() {
	int x = 0;
	x = *g();
}
```
Когда функция `g` завершит свою работу, её переменные "уничтожаться" вместе со стековым кадром функции `g`. 
Указатели на уже несуществующие данные называтся *висячими* (**dangling pointer**)

### Висячие указатели

**При чтении по висячему указателю может произойти:**
- ничего
- прочитается мусорное значение
- программа аварийно завершится

**При записи по висячему указателю может произойти:**
- ничего
- программа аварийно завершится
- внутренний код программы, скрытый от программиста, будет поврежден. Запись по висячему указателю нарушит внутренние структуры программы в памяти, нарушив её логику работы. Программа продолжит работу, но в неожиданный момент аварийно завершится, выполняя, казалось бы, корректное действие вроде вызова функции или выделения массива.



