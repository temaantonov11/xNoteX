[[Computer Science]]

**Архитектура программного обеспечения** - это фундаментальная организация системы, воплощенная в ее компонентах, их отношениях между собой и с окружением, а также принципы, определяющие проектирование и развитие системы. Архитектура ПО определяет, как компоненты системы взаимодействуют друг с другом, как данные обрабатываются и передаются, а также как система масштабируется и поддерживается.
## Типы программных архитектр

- Монолитная архитектура
- Бессерверная архитектура
- Сервис-ориентировання (SoA)
- Архитектура, управляемая событиями
- Архитектура микросервисов
## Монолитная архитектура

**Монолитная архитектура** - традиционный дизайн ПО, при котором все приложения строятся как единое целое. В этом типе архитектуры все компоненты программной системы, включая UI, бизнес-логику и уровни обработки данных, тесно интегрированных в единую кодовую базу.

- Слой представления
- Слой бизнес-логики
- Слой передачи данных (Data link Layer)

![[Pasted image 20250210182020.png]]
### Плюсы
- Простота
- Простота тестирования
- Производительность
### Минусы
- Ограничение **масштабируемости**
- Отсутствие **гибкости**
- Повышенный **риск** сбоя
## Бессерверная архитектура

**Бессерверная архитектура** - подход к разработке ПО, который использует облачные платформы "Функция как услуга" (*FaaS*) для управления выполнением кода, масштабированием и инфраструктурой. В бессерверной архитектуре разработчики сосредоточены только на написании кода, а поставщик облачных услуг занимается управлением сервером, планированием емкости и другими операционными задачами. Это позволяет разработчикам создавать масштабируемые и экономичные приложения, не беспокоясь об обслуживании сервера.
### Ключевые особенности
- Управляемая инфраструктура
- Управление событиями
- Масштабируемость
- Экономия затрат
### Плюсы
- Сокращается время, затрачиваемое на управление и масштабирование инфраструктуры, позволяя разработчикам сосредоточиться на написании кода.
- Может привести к экономии средств, поскольку вы платите только за время выполнения ваших функций, а не за предварительно выделенные ресурсы.
- Поддерживает быструю разработку и развертывание приложений, поскольку функции не имеют состояния и их легко разрабатывать изолированно.

## SoA

**SoA** - подход к проектированию, который делает упор на слабосвязные повторно используемые сервисы, которые можно комбинировать и организовывать для выполнения конкретных бизнес-требований. Эти сервисы взаимодействуют с использованием стандартных протоколов и интерфейсов, что позволяет разработчикам легко создавать новые приложения, организуя существующие сервисы.
### Ключевые особенности
- Слабая связь
- Повторное использование
- Совместимость
- Оркестрация сервисов
## Event-driven architecture

Эта архитектура построена вокруг событий - маленьких отправляемых сообщений, когда что-то происходит в системе.
### Плюсы
- Высокая производительность, поскольку сервисы реагируют на события только когда они происходят
- Легко масштабировать и расширять, добавляя новые обработчики событий
### Минусы
- Труднее тестировать и отслеживать события
- Если события обрабатываются неправильно, то может создать хаос в системе.
## Микросервисная архитектура

**Микросервисная архитектура** разделяет систему на набор мелких автономных частей (микросервисы), где каждая из них выполяет отдельную функцию. Это практически мини-программы. Эти части взаимодействуют между собой через специальные протоколы (например, API).

![[Pasted image 20250210184144.png]]
### Ключевые особенности
- Независимые службы
- Масштабируемость
- Устойчивость к сбоям
- Улучшенная скорость разработки
- Гибкость в выборе технологии
### Плюсы
- Предлагает слабую связанность благодаря высокой степени изоляции.
- Повышает модульность.
- Сбой в одном сервисе не затронет всю систему, поскольку они изолированы.
- Предлагает высокую гибкость и масштабируемость.
- Простота модификации может ускорить итерации.
- Позволяет реализовать улучшенную систему обработки ошибок.
- Решает проблемы с потоками данных, которые бывают у многослойной системы
### Минусы
- Повышенный риск сбоя при обмене данными между сервисами.
- Большим количеством сервисов трудно управлять.
- Требует решения таких проблем, как задержки в сети, балансировка нагрузки и прочих трудностей, свойственных распределенной архитектуре.
- Нуждаемость в комплексном тестировании в распределенной среде.
- На реализацию потребуется гораздо больше времени

