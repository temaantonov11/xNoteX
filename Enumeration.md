[[C]]

**Перечисления** - численный тип данных `int` (Точнее, в зависимости от конкретной архитектуры, перечисления реализуются через `unsigned int`, `signed int` или `char`). Перечисление задает некоторый набор констант, снабженных именами.

Например, светофор может быть в одном из следующих состояний:

```C
enum light {
	RED,
	RED_AND_YELLOW,
	YELLOW,
	GREEN,
	NOTHING
};
```

Обычно это означает, что переменная типа `enum light` в программе может принимать только значения из этого списка. Но в принципе С, к сожалению, не запрещает присваивать любые целые числа в такую переменную:
```C
enum light mylight = RED;
mylight = 1000;
```

Можно явно указать, каким числам соответствуют именные константы:

```C
enum light {
	RED = 100,
	RED_AND_YELLOW = 923,
	YELLOW = 9, 
	GREEN,
	NOTHING
};
```

Часто указывают только значение первого элемента, а последующие в таком случае идут по порядку.

```C
enum light {
	RED = 0,
	RED_AND_YELLOW, // 1
	YELLOW, // 2
	GREEN, // 3
	NOTHING // 4
};
```

В стандарте общее описание перечислений находится в секции 6.7.2.2.
## Применение enumerations

- Один из способов **задать именованную константу без `#define`** - использовать анонимное перечисление.

```C
enum = { A = 320; }

// можно создавать массив такой длины!
char array[A] = {0};

// а массив длины, взятой из глобальной неизменяемой переменной, сделать нельзя:
const int B = 320;
char array2[B] = {0}; // ошибка компиляции
```

- Если сущность в программе может быть в одном из небольшого фиксированного количества состояний, то **удобно применять перечисление для описания текущего состояния**. Например, если мы реализуем конечный автомат.
- Предположим, функция копирует файл из одного места в другое. Операция может завершиться успехом или может произойти одна из многочисленных ошибок:
	- не хватает прав для записи
	- мало места на диске
	- ошибка чтения из файл
Можно разделить логику функции `copy_file` на три части: основные действия и выдача ошибок; выбор соответствия ошибок и сообщений об ошибке; показ сообщений.

```C
enum copy_file_result {
	CF_OK,
	CF_ERROR_OUT_OF_SPACE,
	CF_ERROR_IO
};

enum copy_file_result copy_file (const char* from, const char* to) {
	... 
	пытаемся скопировать файл
	...
	if (на диске не хватает места) {
		return CF_ERROR_OUT_OF_SPACE;
	}
	if (ошибка чтения) {
		return CF_ERROR_IO;
	}
	return CF_OK;
}

const char* const cf_errors_messages[] = {
	[CF_ERROR_OUT_OF_SPACE] = "Не хватает места на диске",
	[CF_ERROR_IO] = "Ошибка чтения с диска"
};

void perform_copy_file(const char* from, const char* to) {
	enum copy_file_result status = copy_file(from, to);
	printf( cf_error_messages[status]);
}
```


Одно из частных применений перечислений, объединений и структур - работа с переменными, котоыре могут хранить данные одного из фиксированного набора типов. Например:

```C
enum animals_type { AT_CAT, AT_FROG };

struct cat {
	const char* name;
	bool meows_often;
	bool obeys;
	const char* master;
};

struct frog {
	bool quacks;
	bool venomous;
};

struct animal {
	enum animal_type type;
	union {
		struct cat as_cat;
		struct frog as_frog;
	}
};
```

Как это работает:
- Структура содержит перечисление и объединение из нескольких типов данных.
- Перечисление явно показывает, какие именно данные хранятся в объединении (потому что неявно во время выполнения эта информация нигде не хранится).

```C
// это кошка
(struct animal) { .type = AT_CAT, .as_cat = { "barsik", true, false, "Bors" } }

// это лягушка
(struct from) { .type = AT_FROG, .as_frog = {false, false} }

void f(struct animal a) {
	if (a.type == AT_CAT) {
		printf("It is a cat");
		if (a.as_cat.meows_often) printf(", it meows\n");
	} else {
		printf("It is a frog");
		if (a.as_frog.venomous) printf(", it is venomous\n");
	}
}
```

Конечно, размер `struct animal` определяется наибольшим из размеров полей объединения. Структура `cat` больше, чем структура `frog`, поэтому когда в объединении хранится лягушка, а не кошка, некоторые байты объединения никак не используются.
