[[C]]
## Типы функций

Функции в С тоже имеют типы, как и более привычные нам данные. 
**Тип функции это её сигнатура:** комбинация типов параметров и типа возвращаемого значения. 
Описываются такие типы не очень привычно:

```C
// ftype -- тип функции, возвращающей int, принимающей 2 аргумента
// типов const char* и float
typedef int ftype(const char*, float);
```

Описание функционального типа похоже на объявление функции:

```C
// Тип функции ftype

typedef int ftype(const char*, float);

// Объявление функции myfunction с такой же сигнатурой
// Можно сказать, что ее тип совместим с ftype
int myfunction(const char*, float);

```

*Псевдоним типа функции можно использовать для объявлений функций с такой сигнатурой. Синтаксически это похоже на объявление переменных:*

```C
typedef void action(const char*);
action print;
action log;
action send;

// то же самое, что:
void print(const char*);
void log(const char*);
void send(const char*);

```

**Чаще всего функциональные типы используются чтобы создавать указатели на функции.**
## Указатели на функции

Функции хранятся в памяти в виде закодированных машинных инструкций, поэтому у них есть адреса. Эти адреса можно использовать для вызова функций, а также записывать в переменные, массивы, или передавать в другие функции в качестве аргумента.

В этом примере мы создаем указатель на функцию типа `int64_t -> int64_t` и присваиваем в него адрес функции `square`. Затем мы вызываем функцию по этому указателю, а не по её имени:

```C
int64_t square( int64_t x ) { return x*x; }

int main() {
	int64_t array[] = {1, 2, 3, 4, 5};
	const size_t count = sizeof(array) / sizeof(array[0]);
	int64_t (*mapper)(int64_t) = &square;
	for ( size_t i = 0; i < count; ++i) {
		array[i] = (*mapper)( array[i] );
	}
	return 0;
}
```

Стоит обратить внимание на скобки вокруг имени `mapper`. Без них было бы непонятно, что звёздочка относится к имени указателя `mapper`, а не к возвращаемому типу. Иными словами, неясно было бы, что это:
- объявление функции типа `int64_t -> int64_t*`
- или указатель на функцию типа `int64_t -> int64_t` (мы бы хотели этот вариант).

Переменная типа указателя на функцию позволяет вызывать через себя то одну функцию, то другую. Для этого достаточно изменить её значение:

```C
int64_t square( int64_t x ) { return x*x; }
int64_t cube ( int64_t x ) { return x*x*x; }

int main() {
	int64_t array[] = { 1, 2, 3, 4, 5 };
	const size_t count = sizeof(array)/sizeof(array[0]);
	int64_t (*mapper)(int64_t) = &square;

	// применение функции на которую указывает mapper
	// ко всем элементам массива
	for (size_t i = 0; i < count; ++i) {
		array[i] = (*mapper)( array[i] );
	}

	// заменим значение mapper и выполним тот же код
	mapper = &cube;
	for (size_t i = 0; i < count; ++i) {
		array[i] = (*mapper)( array[i] );
	}
	return 0;
}
```
## Аргумент, в виде указателя на фукцию

### Задача

С помощью `typedef` определите тип `ftype` функции , которая принимает два аргумента:
- `const float*` 
- (указатель на) функцию, принимающую `struct array` и `int64_t` и возвращающую `size_t`
и возвращает `char`.
### Решение

```C
typedef char ftype(const float*, size_t(*)(struct array, int64_t));
```

`size_t(*)(struct array, int64_t)` - указатель на функцию, принимающую `struct array` и `int64_t` и возвращающую `size_t`.

## Функции высшего порядка

Указатели на функции это мощный инструмент написания краткого и выразительного кода.

Функции, которые принимают другие функции в качестве аргумента, называются _функциями высшего порядка (higher order functions)_.

### Пример

Вернемся к примеру с применением двух разных функций к каждому элементу массива. Можно думать об этом коде так: каждый элемент массива мы возводим в квадрат и удваиваем. Другими словами, мы хотим уметь "к каждому элемента массива применить какую-то трансформацию", при этом трансформация может быть "возвести в квадрат" или "удвоить". Мы абстрагируемся от того, какая именно это будет трансформация; каждый раз она может быть разной. Чтобы минимизировать количество кода:
- Опишем логику применения произвольной трансформации `T` к каждому элементу массива как отдельную функцию `map`; `T` будет её параметром.
- Оформим каждую интересующую нас трансформацию в виде отдельной функции.
- Для применения трансформации к каждому элементу массива передадим в `map` адрес функции, реализующей её.

```C
int64_t square( int64_t x ) { return x*x; }
int64_t cube( int64_t x ) { return x*x*x; }

// параметр-указатель на функцию можно писать без звёздочки
void map( int64_t* array, size_t count, int64_t T(int64_t) ) {
	for (size_t i = 0; i < count; i += 1) {
		array[i] = T( array[i] );
	}
}

int main() {
	int64_t array[] = { 1, 2, 3, 4, 5 };
	const size_t count = sizeof(array)/sizeof(array[0]);
	map( array, count, square );
	map( array, count, cube );
	return 0;
}
```

Мы отделили логику *проходу и какой-то трансформации массива от трансформации конкретного элемента массива;* теперь первую часть мы можем переиспользовать. Это уменьшило количество кода и подняло уровень абстракции (например, мы больше не думаем каждый раз про границы массива). Как следствие, нам стало легче отлаживать программу, писать и читать код. Фрагмент программы, выглядивший как "примени к каждому элементу массива функцию", легче читается, чем "заведи счетчик типа `size_t`, считай от 0 до размера массива -1...".

Компиляторы умеют встраивать функции типа `map` в месте вызова так, чтобы сгенерировать машинный код был идентичен обычному циклу с применением трасформаций к элементам массива. То есть введение дополнительных функций и их вызов может вообще никак не сказаться на сгенерированном машинном коде.
## Преобразование указателей на функции

>[!info] Внимание
>По стандарту языка нельзя использовать указатели на данные как указатели на функции, и наоборот.

Мы уже знаем про тип `void*`, который обозначает "указатель на что угодно". По стандарту языка С это "что угодно" может быть только *типом объекта*. Здесь *объект* понимается **не в смысле ООП** - стандарт называет объектом **любые данные, которые хранятся в памяти абстрактного вычислителя**: числа, объединения, строчки, структуры и перечисления, массивы, .... **но не функции!** Поэтому тип `void*` по стандарту нельзя преобразовать в тип указателя на функцию и наоборот.

Типы указателей на функции, однако, можно преобразовывать друг к другу. При этом сколько бы мы между ними не делали конвертаций, если в конце привести тип указателя так, чтобы он соответствовал сигнатуре функции, на которую он указывает, то мы сможем корректно вызывать эту функцию по указателю:

```C
char f(char x) { return 'a' + x; }
char (*p1)(char) = f;

// преобразуем в const int64_t -> void
// обязательно явно конвертировать
void (*p2)(const int64_t*) = (void (*)(const int64_t*))(p1);
//                         |________________________| в этот тип мы преобразуем p1 
// это тип указателя на функцию, которая принимает const int64_t* и ничего не возвращает

// преобразуем обратно в char -> char
char (*p3)(char) = (char (*)(char))(p2);

// вызовем f через p2
p3(2); // корректно, т.к тип p3 соответствует типу f, вернет 'c'.
```

Если же это преобразование обратно не сделать, то не гарантируется, что вызов будет совершен правильно:

```C
void f(void* x) {}

void (*p1)(void*) = f;
void (*p2)(int64_t*) = (void (*)(int64_t*))(p1);

p2(NULL); // некорректно!
		 // тип f: void* -> void
		 // p2 указывает на: int64_t* -> void
```

Однако стандарт [POSIX](https://ru.wikipedia.org/wiki/POSIX) требует, чтобы указатели на функции можно было записывать в `void*` а затем преобразовывать обратно.
### Тип функции и тип указателя на функцию

Чаще всего мы используем указатель на функцию чтобы вызвать функцию через него. Для удобства указатель на функцию преобразуется в её собственный тип неявно:
#### Неявное преобразование

Следующие две строчки эквивалентны:

```C
array[i] = (*mapper)( array[i] );
array[i] = mapper( array[i] );
```

Указатель на функцию прозрачно преобразуется в тип самой функции, что позволяет не разадресовывать его для вызова.

Кроме того, имя функции прозрачно преобразуется в её адрес:

```C
int64_t double( int64_t x ){ ... }

int64_t (*mapper)(int64_t);
mapper = &double;
mapper = double;
```