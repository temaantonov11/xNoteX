[[C]]

# Куча (Heap)

Можно считать, что память под данные в С выделяется тремя способами:
- в стеке (почти все локальные переменные)
- в области глобальных данных (в основном глобальные переменные)
- в куче

>[!info] Определение
>**Куча** - это специальная область памяти, в которой можно резервировать блоки под текущие нужды. В отличие от стека, в куче можно попытаться выделить много памяти, и даже если это не получится, программа не сломается.

Чтобы запросить резервирование блока в куче мы пользуемся функцией `malloc` из стандартной библиотеки языка С. Она вернёт адрес начала выделенного участка памяти. 

```c
/* Необходим заголовочный файл malloc.h */
#include <malloc.h>

void g() {
	// этот массив выделен в стеке
	int64_t marray[2] = {10, 20};
	// память под него освободиться автоматически
}

void f() {
	// этот массив выделен в куче
	int64_t* marray = malloc( sizeof(int64_t) * 2);

	marray[0] = 10;
	marray[1] = 20;

	// память под указатель освободиться автоматически
	// память под массив останется зарезервированной
}
```

>[!info] Сигнатура функции `malloc`:
>```c
>void* malloc(size_t size);

Функция принимает запрос на размер массива в байтах и возвращает указатель на начало выделенного массива. Если выделить память не получилось, то будет возвращен `NULL`.

В массиве, выделенном `malloc`, хранится мусор. Мы ничего не можем предполагать о значении его байтов, и он уж точно не будет заполнен нулями.

Если мы зарезервировали память с помощью `malloc`, она будет оставаться зарезервированной, пока программа не завершит свою работу. Если бесконтрольно выделять всё больше памяти с помощью `malloc`, то потребление программой будет расти, пока вся доступная для кучи память не станет зарезервированной. Тогда:
- вырастет потребление памяти программой
- `malloc` не сможет выделять память

Нужно освобождать эту память вручную с помощью функции `free`:
>[!info] Сигнатура функции `free`
>```c
>void free(void* ptr);

Один из следующих вызовов `malloc` переиспользует память, освобожденную с помощью `free`. 

Основные проблемы ручного управления памятью в куче такие:
- Не забывать вызывать `free` для каждого выделенного блока;
- Не вызывать `free` дважды для одного и того же блока;
- Не вызывать `free` до того, как данные действительно перестанут быть нужны (иначе мы затем обратимся к уже освобожденному блоку)

По возможности стоит избегать выделения памяти в куче если без него можно обойтись. Например, место под небольшие данные можно выделять в стеке, а затем передавать указатель на них в функции, которые с ними будут работать. Иногда можно использовать глобальные буферы, но функции не должны обращаться к ним напрямую: всегда лучше передавать указатель на буфер в функцию как аргумент.

### Отличия выделения памяти на стеке и на куче

В чём отличия выделения памяти с помощью `malloc` и выделения памяти в области локальных переменных?
1. Локальные переменные убиваются, когда их функция завершает работу. Если мы этого не хотим, придётся использовать `malloc`. В следующем коде **распространенная ошибка:**
```c
char* f() {
	char x[100];
	...
	// возвращаем адрес локальных данных
	// данные уничтожаются
	// при попытке использовать их адрес программа может аварийно завершиться
	return x;
}
```

С другой стороны, память выделенная в стеке, освобождается сама, за ней не нужно следить. А если не освободить память, выделенную в куче, после её использования, то она повиснет на программе мертвым грузом.
2. Выделить большой объем данных на стеке нельзя - стек переполнится и программа аварийно завершит работу. Выделить большой кусок данных в куче и получить на него указатель можно всегда. Если памяти не хватит, то `malloc` вернёт `NULL`, можно это проверить и сообщить пользователю, что памяти не хватает.
3. В общем случае выделить память в стеке можно только зная заранее, сколько её нужно. Нельзя считать чисто `n` от пользователя и потом выделить в стеке ровно `n` байт.

### Когда не стоит использовать кучу?

Если можно обойтись без кучи, нужно это делать. Помимо того, что память в куче надо освобождать вручную, куча работает значительно *медленнее*, чем стек. Более того, выделение памяти в куче может занимать очень разное количество времени в зависимости от её текущего состояния. 

Не используйте кучу если нужно выделить буфер небольшого размера (скажем, пару килобайт). Мы можем даже не знать точного размера необходимого буфера, но если он не превышает фиксированного числа, можно выделить память в стеке с запасом.

### `calloc` и `realloc`

Существуют также функции `calloc`и `realloc`

`realloc` пытается выделить блок другого размера, скопировать туда содержимое старого блока (сколько получиться) и деаллоцировать старый. Если выделить новый блок не получилось, старый не будет деаллоцирован.

>[!info] Сигнатура функции `realloc`
>```c
>void *realloc(void *ptr, size_t size);

`calloc` выделяет память как `malloc`, но также записывает в неё нули. Размер выделенной памяти - произведение размера элемента `size` и количества элементов `nmemb`.

>[!info] Сигнатура функции `calloc`
>```c
>void *calloc(size_t nmemb, size_t size);

Имейте в виду, что запись нулей в память не всегда означает запись туда нулевых значений. К примеру, указатель в никуда `NULL` на некоторых архитектурах может кодироваться числом, в котором, наоборот, все биты равны единицам. Или число с плавающей точкой 0.0 типа `double` может представляться иначе, чем 8-байтовым числом, в котором все биты равны нулям. Поэтому обнуление памяти с помощью `calloc` (или, например, функции `memset`) в общем случае *не означает корректной инициализации данных нулевыми значениями*.