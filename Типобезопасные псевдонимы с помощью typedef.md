[[C]]

В случае, когда новый тип является просто оберткой над старым, считается допустимым использовать `typedef` совместно с объявлением структурного типа, вот так:

```C
typedef struct {
	char* addr;
} heap_string;
// heap_string это псевдоним для анонимного структурного типа struct { char* addr }
// так мы не создаем структурного типа с именем и можем использовать heap_string
// без ключевого слова struct
// Здесь struct используется как хак для создания псевдонима типа без добавления 
// неявных конверсий
// и никак не означает, что внутри неё - большая структура данных

void print_and_deallocate( heap_string s ) {
	printf(s.addr);
	free(s.addr);
}
```

Так можно помечать данные и другой информацией.
Например, пользователь вводит любое число, но программа ожидает число от 5 до 7. После проверки можно упаковать число в структуру:

```C
typedef struct {
	int64_t value;
} sanitized_int;

sanitized_int sanitize( int64_t i ) {
	if (5 <= i && i <= 7) {
		return (sanitized_int) { .value = i };
	} else {
		// аварийное завершение, но можно сделать разумную обработку ошибки
		abort();
	}
}

void do_something( sanitized_int i) {
	// в этом месте есть гарантия, что 5 <= i <= 7
	// произвольное число без упаковки мы передать не можем
}
```

Еще несколько применений для упакованных по-разному данных одного типа:
- Идентификаторы разных сущностей в программе часто являются целыми числами: ID процесса, файловые дескрипторы, ...  .С помощью структур их можно различать чтобы не передавать в функцию, ожидающую файловый дескриптор, длину в метрах.
- Метры, килограммы, литры, км/ч - нельзя, скажем, складывать величины разной размерности, хотя все они выражаются числами.