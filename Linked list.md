[[C]] [[Data Structures & Algorithms]]


Почти в любой программе есть необходимость хранить данные в каком-то контейнере, коллекции.
Обычно нам необходимо производить с ней следующие операции:
- Доступ к элементам по индексу
- Добавление элемента:
	- в начало
	- в конец
	- в произвольную позицию по индексу
- Сортировку в каком-то порядке

**Связный список** - структура данных, один из возможных контейнеров для данных одинакового типа. Список состоит из цепочки элементов, каждый из которых хранит значение и адрес следующего элемента.

![[Pasted image 20250211203853.png | 600]]

В связный список удобно **добавлять элементы в любое место**, но доступ по индексу сложнее - нужно посмотреть весь список с самого начала.

## Coding

```C
// list - тип элементов списка

struct list {
	int64_t value;
	struct list* next;
};
```

Список задается указателем на его первый элемент. Если список пустой, то этот указатель устанавливается в `NULL`.
```C++
struct list* mylist = NULL; // этот список пустой
```

Непустой список задается ненулевым указателем на первый элемент.

Список (1, 2, 3) в коде можно представить так:

```C
struct list {
	int64_t value;
	struct list* next;
};

struct list x3 = {3, NULL};
struct list x2 = {2, &x3};
struct list x1 = {1, &x2};

struct list* mylist = &x1;

```

Началом списка будет являться указатель `mylist` на `x1`.
### Полный пример кода для определения и вывода

```C
struct list {
	int64_t value;
	struct list* next;
};

void list_print(const struct list* l) {
	while (l) {
		printf("%" PRId64 " ", l->value);
		l = l->next;
	}
}

int main() {
	struct list x3 = {3, NULL};
	struct list x2 = {2, &x3};
	struct list x1 = {1, &x2};

	struct list* mylist = &x1;

	list_print(mylist);
	return 0;
}
```

### Создание ноды

```C
struct list* node_create( int64_t value) {
    struct list* node = malloc(sizeof(struct list));
    node->value = value;
    node->next = NULL;
    return node;
}

```
### Добавление элемента к началу списка

1. Создать новый элемент.
2. Прицепить старый список к нему.
3. Перенаправить указатель на первый элемент так, чтобы он указывал на новое начало списка.
Чтобы иметь возможность изменить указатель на первый элемент, мы должны передать в функцию его (указателя) адрес, то есть *указатель на указатель* на первый элемент списка.

