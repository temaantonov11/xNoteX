
## Модульность
Программу лучше разбить на небольшие файлы; каждый из таких файлов с кодом, имеющих расширение `.c`, называется *модулем* и может компилироваться отдельно от других файлов с кодом. 
Хорошо, когда мы чётко определяем, какую функцию выполняет тот или иной модуль, и помещаем туда только соответствующий код. Если мы тщательно продумаем этот вопрос, модули помогают нам в поиске ошибок. 
## Абстракция
==Абстракция это принцип проектирования систем, который позволяет нам забыть об устройстве части системы и использовать её как черный ящик==. Для нас важно, как эта часть себя ведет, а не какие детали внутренного устройства обуславливают это поведение. Такой частью не обязательно является целый файл, это может быть, например, функция: функции тоже позволяют абстрагироваться от того, как именно получен результат вычислений. Достаточно запустить функцию с нужными аргументами, а затем работать со значением, которое она вернула. 

Чаще всего об абстракции в С думают на уровне файлов с кодом. Для каждого файла, скажем, `lib.c`, в котором находятся функции, которые нужно вызвать из других файлов, пишут так называемый *заголовочный файл* с таким же именем, но расширением `.h`

![[Pasted image 20241229214019.png]]

## Препроцессор

Первым этапом компиляции программ является *препроцессинг*. Это чисто текстовая предобработка, своеобразная умная замена одних строчек на другие, которой занимается специальная *программа-препроцессор*. Мы управляем препроцессингом с помощью **директив препроцессора** прямо в тексте программы. 
К директивам относятся:
- `#include` включает содержимое другого файла (и пропускает его через препроцессор)
- `#define` определяет новый **символ препроцессора**. Символом препроцессора называют некий идентификатор, которому препроцессор ставит строчку в соответствие. Написав `#define X hello` мы далее все идентификаторы `X` будем заменять на `hello`. 

Чтобы решить проблему с многократным включением заголовочных файлов, нам потребуется еще несколько директив:
```c
// можно поставить в соответствие X пустую строку
#define X
// главное, что теперь X определен

#ifdef X
/* Если до этого символ X был определен (да),
	то включить тект  до #endif
	Этот блок включен
*/
#endif

#ifndef X
/* Если до этого символ X не был определен (нет),
	то включить текст до #endif.
	Этот блок пропущен.

*/
```

## Include guard
Чтобы предотвратить многократное включение файла, почти всегда пользуются трюком под названием *Include Guard*. Его цель в том, чтобы, используя препроцессор, ограничить возможность включения одного файла в другой одним разом. То есть, для каждого модуля любой заголовочный файл можно включить в него только один раз, а повторные включения ни к чему не приводят. Напротив, заголовочный файл по прежнему можно включить в любое количество модулей. 

Опишем *Include Guard* для произвольного файла `file.h`
```c
/* Так теперь выглядит file.h */
#ifndef FILE_H
#define FILE_H
/* содержимое заголовочного файла:
	объявления функций, переменных и т.д
*/

#endif

```

Включив `file.h` в первый раз, мы определим символ препроцессора `FILE_H`. При каждом дальнейшем включении `file.h` этот символ будет уже определен, и директива `#ifndef` пропустит текстовый блок до `#endif`, то есть повторное включение `file.h` вставит пустую строку, чего мы и добивались.

```c
#include "file.h" // включит содержимое файла
// Теперь FILE_H определен
#include "file.h" // заменится на пустую строку
#include "file.h" // заменится на пустую строку
```

Выбрали имя для символа `FILE_H` так, чтобы оно было похоже на имя файла. Имя символа должно быть очевидно, уникально.

## Уточнение про `#include`

Разница в кавычках в следующем:
- директивна `#include <file.h>` ищет файл в стандартных директориях, на которые настроен компилятор (их можно доопределять)
- `#include "file.h"` ищет файл сначала в текущей директории, затем в стандартных директориях из прошлого пункта

Как правило, файлы из библиотек (как стандартной, так и сторонних) пишутся в угловых скобках, а файлы из самого проекта - в кавычках. 
