[[OS]]

OS - прослойка между hardware и software. 

Все, что находится во владении ядра (память, его код) называется **kernel space**, а все остальное называется **user space**. У **kernel space** есть права работать с железом. 

Пользовательский код может получать доступ к ядру, его сервисам (возможность писать на диске, читать с сети, обращаться к железу) через **системные вызовы (system calls)**. Они вызываются в **user space**, а исполняются в **kernel space**.
К примеру, из user space кода мы не можем сами писать на диск, мы должны вызвать sys call, который для нас это сделает. Функция `printf` это обертка над sys call-ом `write`, который выполняет еще кучу кода в user space для обработки строки.

Другая важная задача ядра - работа с **аппаратными прерываниями**. Аппаратные прерывания - электрические сигналы, которые приходят на процессор и прерывают текущую задачу, которую он исполнял, заставляя его вызвать обработчик этого конкретного сигнала и процессор как-то реагирует. Если ядро уже занято критической задачей (к примеру, обрабатывает другое прерывание), то *прерывания собираются в очередь*. Прерывания исполняются не в user space, но и не совсем в kernel space. Это отдельный контекст, который называется *режим прерываний* (*interrupts mode*). Прерывания приходят на конкретный пин на процессоре, поэтому процессор знает откуда пришло прерывание и как его обрабатывать + если процессор знает, от какого устройства пришло прерывание, он может напрямую к нему обратиться и узнать какие-либо данные. Прерывания, когда они обрабатываются, в первый раз после возникновения на процессоре не делают всю работу сразу. Они создают задачу в ядре, которая добавляется в очередь и потом ядро исполняет задачи из этой очереди. Разделение на обработку прерывания в 2 этапа: создание задачи и исполнение задачи называется **top half** и **bottom half**. **Top half** - быстрая обработка прерывания, начальная и блокирующая остальные прерывания. **Bottom half** - исполняется в отдельном контексте. 

**Bootloader** (загрузчик) - программа, которая способна найти операционную на диске, дать пользователю выбрать какую-то одну (или по дефолту выбрать самой) и запустить ядро. 
**BIOS** - встроенное ПО, которое запускается напрямую железом при запуске ЭВМ. Это машинный код, который оживляет все железо в системе, дальше эта программа способна найти bootloader на диске (**Master boot record** - в начале устройство какое-то конкретное количество байт имеет определенную структуру, которую **BIOS** умеет распарсить и найти там локацию на **Bootloader**) и передать ему управление. **BIOS** записан в специальной области памяти - **ROM** (Read only memory). **BIOS** способен работать напрямую с железом, вместо ядра, пока ядро не запустится. **BIOS** запускает все устройства, подключенные к материнской плате (включая GPU). 
**ROM** - это устройство, которое состоит из массива транзисторов, куда производитель физически сохраняет программу, которая при подаче электрического сигнала запускается.
При запуске машины процессор получает питание и переходит в **ROM** (его адрес зашит хардкодно в процессор) и запускает **BIOS**.

## Linux kernel
Linux kernel имеет подсистемы:
- **Processes**
- **Hardware**
- **TIme**
- **Filesystem**
- **IPC**
- **Network**
- **Users**
- **Data structures**
- **Virtualization**

### Processes 
Подсистема для управления процессами.

**Process** - единица исполнения программного кода (запущенная программа).
В ядре каждый процесс представлен структурой `task_struct`

#### Часть структуры `task_struct`:
```C
struct task_struct {
	struct thread_info thread_info;
	long state;
	void *stack;
	atomic_t usage;
	unsigned int cpu;
	int prio;
	struct mm_struct *mm;
	int exit_state;
	int exit_code;
	int exit_signal;
	pid_t pid;
	struct task_struct *parent;
	struct list_head children;
	const struct cred *cred;
	struct file_struct *files;
};
```

#### Жизненный цикл процесса

![[Pasted image 20250227114943.png]]

#### Thread and Process
В linux нет понятия потоков и процессов на уровне ядра. Они есть в **user space**. В ядре их нет. Ядро оперирует **task-ами** (задачами). Самое близкое понятие к задаче - это поток. Грубо говоря, ядро оперирует потоками. 

### Hardware
Большинство устройств работают с ядром через драйвера. 
**Драйвер** - специальный модуль, программа, которая загружается в ядро (статически или динамически) и способна работать с каким-то конкретным устройством. 

### Time
Подсистемы управления временем ответственны за то, чтобы замерять тикание железных часов внутри, за таймеры внутри, за то, чтобы будить user space процессы, за шедулинг тасок на физических ядрах процессора. 
Для времени на уровне железа используются: **Oscillator** (для тиков) и **Real Time Clock** для хранения текущего времени и передачи в ядро.

### FS
Файловых систем бесконечное количество и для того, чтобы унифицировать работу с файловой системой в ядре есть **VFS** (Virtual File System).
**VFS** - модуль, главный компонентом которого является абстрактный класс (структура с указателями на функции) `struct file_operation`. В которой объявлены функции для работы с файловой системой. И когда хотят реализовать поддержку файловой системы в линуксе, они должны реализовать все функции для работы с FS, создать структуру `file_operation` и передать в ядро, когда файловая система там регистрируется. Таким образом, с файловыми системами разных типов ядро работает одинаково.

```C
// часть file_operation
struct file_operation {
	loff_t (*llseek) (struct file*, loff_t, int);
	ssize_t (*read) (struct file*, char _user*, size_t, loff_t*);
	ssize_t (*write) (struct file*, const char _user*, size_t, loff_t *);
	int (*mmap) (struct file*, struct vm_area_struct *);
	int (*open) (struct inode*, struct file*);
	int (*flush) (struct file*, fl_owner_t id);
	int (*fsync) (struct file*, loff_t, loff_t, int datasync);
	int (*flock) (struct file*, int, struct file_lock *);
	long (*fallocate) (struct file *file, int mode, loff_t offset, loff_t len);
};

struct super_block {
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	int s_count;
	struct list_head s_mounts;
};
```

### IPS
Способы взаимодействия процессов внутри одной системы. 

### Network
Реализованы инструменты для работы с сетями.

### Users

```C
struct cread {
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	struct user_struct *user;
};
```

### Scheduler

- Cooperative multitasking - задача сама выбирает, сколько времени она будет занимать ядро. Применяется в корутинах. 
- Preemptive multitasking - задачу выкидывает ядро, передавая управление другой задаче

#### Types of scheduler

- **Dumb scheduler**
- **O(1) scheduler**
- **Completely Fair Scheduler**

Таски делятся на:
- **I/O Bound** - Disk, Network, Interactive
- **CPU Bound** - Transaction processing, Calculations

#### Priority
nice -- executive a utility with an altered scheduling priority
renice -- alter priority of running processes
chrt -- manipulate the real-time attributes of a process

```C
int
getpriority(int which, id_t who);

int
setpriority(int which, id_t who, int prio);

int 
nice(int inc);
```





